博弈论例题讲解
========
****
例1：取石子问题
--------
	问题描述：
	小王喜欢与同事玩一些小游戏，今天他们选择了玩取石子。
	游戏规则如下：共有 N 堆石子，已知每堆中石子的数量，两个人轮流取子，
	每次只能选择 N 堆石子中的一堆，取一定数量的石子（最少取一个），取过子之后，
	还可以将该堆石子中剩下的任意多个石子中随意选取几个放到其它的任意一堆或几堆上。
	等哪个人无法取子时就表示此人输掉了游戏。
	注意，一堆石子没有子之后，就不能再往此处放石子了。
	假设每次都是小王先取石子，并且游戏双方都绝对聪明。
	现在给你石子的堆数、每堆石子的数量，请判断出小王能否获胜。
****

	问题分析：在博弈论的例题中，我们首先需要找到游戏过程的必胜/必败态，这两者是相互转化的
	对于先手游戏的一方来说，将游戏的局势转化为必败态（奇异态）传递给对手则可以获得胜利
	能通过一次游戏步骤转化为必败态的状态就是必胜态
	这个题目对思维的要求较高，我们分析这个题目的必败态：
	如果石子放置方式为：(ni>1,n>1)，重要结论会用-------(N)标出
	1 0 则先手拿取第一堆的石子1个则必胜
	n 0 先手拿空一堆则必胜-------(1)
	1 1 由于先手必须拿一个子，则必败
	2 1 先拿第一堆一个子，给对手1 1的必败态，必胜
	n 1 把第一堆拿到只有1个子，给对手1 1的必败态，必胜
	2 2 无论怎么拿，都会转化为2 1或者2 0的必胜态给对手，必败
	n n 无论怎么拿都可以通过转移石子转化为n n，从而导致1 1，必败-------(2)
	1 1 1 由于每次必需取1个子，先手必胜
	2 1 1 先手取空一堆，转化为1 1的必败态，必胜
	n1 n n 先手取空n1的堆，转化为n n的必败态，必胜
	n1 n2 n3 取其中任意一堆一定量，通过转移剩余的石子为n n的必败态，必胜
	1 1 1 1 由于每次必需取1个子，先手必败，此时可发现偶数个1必败
	2 1 1 1 先手取第一堆一个子转化为1 1 1 1的必败态给对手，必胜
	2 2 1 1 无论先手怎么取，会转化为2 1 1 1或2 2 1或者2 1 1的必胜态，必败
	n n n1 n1 无论先手怎么取，后手都可以构造ni ni nj nj的状态，
	例如，先手取完为 n+i n+j n1-i-j n1+k,后手可以在第四堆取i+j+k个石子构造
	n+i+j+k/2 n+j+i+k/2 n1-i-j n1-i-j状态，等价于n n n1 n1状态
	取足够多次后，在后手取完时会产生nk nk的必败态，先手必败-------(3)
	n n n n 先手取完后会转化为n1 ni ni ni, n1 n2 ni ni, n1 n2 n3 n4四种状态
	这三种状态都可以被后手转化为ni ni nj nj的必败态，先手必败-------(4)
	拓展到偶数个n时，同理最终会转化为n n的必败态，必败-------(5)
	对于奇数2n+1个堆，都可以转化为2n个相同石子数量的堆，由(5)，转化后的局势为必败态，先手必胜-------(6)
	n n n n n1 n1 即两个必败态n n n n和n1 n1组合，不失一般性假设n1>n，先手取石子后的情况为：
	n+a n+b n+c n+d n1-(a+b+c+d+x+1) n1+x，则后手可以对n1取a+b+c+d+x+1个子，转换为：
	n+a+d n+b+c n+c+b n+d+a n1-(a+b+c+d+1) n1-(a+b+c+d+1)
	这个时候，发现状态转换为 n1 n1 n2 n2 n3 n3的状态
	这时先手对n1取石子，转换为n1-(x+a1+a2+b1+b2+1) n1+x n2-a1 n2-a2 n3-b1 n3-b2
	则同样，后手模仿先手的行为，对n1+x取x+a1+a2+b1+b2+1个石子：
	n1-(a1+a2+b1+b2+1) n1-(a1+a2+b1+b2+1) n2+a1+a2 n2+a2+a1 n3+b1+b2 n3+b2+b1
	转化为状态n4 n4 n5 n5 n6 n6，等价于原来的状态，造成循环，在取足够大后，必然先手面对n n的必败态
	我们多试几组：
	n n n n n n n1 n1 n1 n1 n2 n2
	假设n n1 n2足够大
	先手取完石子后转化为：
	n+a1 n+a2 n+a3 n+a4 n+a5 n+a6 
	n1+b1 n2+b2 n3+b3 n4+b4 
	n-(a1+a2+a3+a4+a5+a6+b1+b2+b3+b4+x+1) n+x
	此时后手可以对最后的n+x堆取a1+a2+a3+a4+a5+a6+b1+b2+b3+b4+x+1个石子，转化为：
	n+a1+a6 n+a2+a5 n+a3+a4 n+a4+a3 n+a5+a2 n+a6+a1 
	n1+b1+b4 n2+b2+b3 n3+b3+b2 n4+b4+b1 
	n-(a1+a2+a3+a4+a5+a6+b1+b2+b3+b4+1) n-(a1+a2+a3+a4+a5+a6+b1+b2+b3+b4+1)
	构成了状态n3 n3 n4 n4 n5 n5 n6 n6 n7 n7 n8 n8，同理进入循环
	对于n...n堆数为偶数时，先手在首堆取k[1]+k[2]+...+k[t]+1个石子，取完后为：
	n-(k[1]+k[2]+...+k[t]+1) n+k[1] n+k[2] n+k[3] ... n+k[t]
	后手模仿先手对n+k1取k1+k2+...+kt+1个石子：
	n-(k[2]+...+k[t-1]+1) n-(k[2]+...+k[t+1]) n+k[2]+k[t-1] n+k[3]+k[t-2] ... n+k[t]k[1]
	这样循环下去最终得到n...n的状态，说明先手和后手在偶数个相同堆见循环模仿取石子不改变堆的性质------(7)
	我们假设初始状态n...n n1...n1 n2...n2 ~ nt...nt每相同石子数的堆数为偶数
	假设所有数据足够大，则：
	不失一般性，对首堆n开始取石子，由于(7)，其他石子数为n的堆可以不取
	先手取石子后状态为：
	n-(∑∑ai[ji]+1)
	n ... n
	n1+a1[1] n1+a1[2] ... n1+a1[j1] 
	n2+a2[1] n2+a2[2] ... n2+a2[j2] 
	...
	nt+at[1] nt+at[2] ... nt+at[jt] 
	则后手对第二个堆n取石子∑∑ai[ji]+1
	可以得到
	n-(∑∑ai[ji]+1) n-(∑∑ai[ji]+1)
	n ... n
	n1+a1[1]+a1[j1] n1+a1[2]+a1[j1-1] ... n1+a1[j1]+a1[1]
	n2+a2[1]+a2[j2] n2+a2[2]+a2[j2-1] ... n2+a2[j2]+a2[1]
	...
	nt+at[1]+at[jt] nt+at[2]+at[jt-1] ... nt+at[jt]+at[1] 
	此时构成了
	n...n m0 m0 m[1] m[]1 m[2] m[2] ... m[1/2∑ji] m[1/2∑ji]
	在足够多次的取石子后转化为：
	p1 p1 p2 p2 ... p[SUM] p[SUM], SUM=(length(n)+∑length(ni))/2
	进行多次取石子后转化为n n的必败态
	说明：堆数为偶数，且相同石子数的堆数也为偶数时才为必败态


	#include<iostream>
	#include<cstring>
	using namespace std;
	int main(){
		int n=0,num=0,win=0,tempn=0;
		int map[101]={0};
		while(cin>>n,n){//n为0推出程序 
				tempn=n;
			for(int i=0;i<n;i++){
				cin>>num;
				if(num==0) tempn--;
				//输入的石子数量为0是错误输入,将总堆数减去0石子的堆数 
				map[num]++;
			}
			if(tempn&1){//只要堆数为奇数就可以赢 
				win=1;
			}
			else{
				for(int i=1;i<101;i++){
						if(map[i]&1) {
								win=1; 
								break;
						}//只要相同石子数的堆数为奇数则可以赢 
					}
			}
			if(win) cout<<"Win";
			else cout<<"Lose";
			cout<<endl;
			memset(map,0,sizeof(map));
			win=0;
		}
	} 
