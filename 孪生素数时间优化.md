问题描述：如果 m 和 m + 2 都是素数，则称它们是孪生素数。输入一些正整数 m，输出两个数均不超过 m 的最大孪生素数。
-------
	非常弱智的题，对原题做了点改动
	普通的方法判断素数为O(n^0.5)，对输入的m，要从末尾m遍历到头5每次判断两个数是不是素数
	即每次判断O(n^0.5)和O((n-2)^0.5)
	从m到5考虑最坏情况为O(5^0.5)+O(6^0.5)+...+O(n^0.5)=
	除了头两个和尾两个数每个数都判断了两次，多了O(7^0.5)+O(8^0.5)+...+O((n-2)^0.5)
	总体时间复杂度为O((4/3)\*(n^(1.5)))-O((n-1)^0.5+(n)^0.5)-O(C)
	如果每个只判断一次，且遇到偶数直接判断为合数，时间复杂度大大降低
	可以设置长度为m的数组，将判断的结果记录下来（类似动态规划的记忆过程）
	#include <iostream>
	#include <cmath>
	using namespace std;
	int plist[10001]={0};
	int isprime(int n){
		if(n==1||n==2||n==3) return 1;
		if(!(n&1)) return 0;
		int i;
		for(i=2;i<=sqrt(n);i++){
			if(n%i==0) return 0;
		}
	//	cout<<endl<<" i="<<i<<"sqrt(n)="<<sqrt(n)<<endl;
		return 1;
	}
	int main(){
		int n=0,i=0,j;
		int temp;
		while(cin>>n){
	//		cout<<"@@@su"<<isprime(n)<<endl;
	//		cout<<"###ji"<<(n&1)<<endl;
			for(i=n;i>=5;i--){
				if(!(i&1)) {//偶数跳过 
					continue;
				}
				//讨论奇数的情况 
				if(plist[i]==0){//该奇数为赋值 
					plist[i]=isprime(i);	
				}
				if(plist[i-2]==0){//该奇数-2未赋值 
					plist[i-2]=isprime(i-2);
				}
				//刚赋完值或者已经赋值好 
				if(plist[i]==1&&plist[i-2]==1){//i和i-1都为素数标志 
					cout<<i-2<<" "<<i<<endl;
					break; 
				}
			}
		}
	}
