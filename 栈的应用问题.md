例1：列车出站顺序
===========
Q:某火车站铁轨上有 n 节车厢自 A 方向进入车站，按进站方向编号为 1 ~ n。现对其进行编组，编组过程可借助中转站 Station，
其中 Station 可停靠任意多车厢，由于 Station 末端封顶，故驶入 Station 的车辆必须按相反方向驶出到B。
对每个车厢，一旦自 A 进入 Station，就不能再驶入 A；且一旦自 Station 驶入 B，再不能返回 Station。
给定长度为 n 的一串在B中的车厢编组值，请判断该车厢编组顺序是否正确。
****
	列车车厢进入Station即进入了栈中，末端封顶的Station符合栈先进后出的特点，该问题转化为判断顺序整型数组入栈产生的可能输出结果。
	对程序的设计：（多组输入）输入一个整数n，则产生1~n的数组，作为初始的编号，再输入需要判断的出栈顺序；
	我们对出栈顺序进行分析：
	输入 
	5
	1 2 3 4 5
	5
	5 4 1 2 3
	6 
	6 5 4 3 2 1
	输出
	Yes
	No
	Yes
	可见，输入的出栈顺序的第一个元素决定的栈内元素的初始化，
	第一个输入初始化栈内有1个元素1，
	第二个输入初始化栈内有5个元素[1,2,3,4,5]，
	第三个输入初始化栈内有6个元素[1,2,3,4,5,6]，
	紧接着弹出输入的第一个元素，即直接进行弹栈操作。代码描述为：
	for(int i < temp) s.push(i);
	s.pop()
	对于第一个输入串12345，是经过push(1)pop(1)push(2)pop(2)...push(5)pop(5)产生的；
	对于第二个输入串54123进行模拟：push(1,2,3,4,5)pop(5)pop(4)此时栈顶为3，不可能将1出栈因此错误，
	即当前的元素不等于栈顶元素；
	对于第三个输入串654321，经过push(1,2,3,4,5,6)pop(6)pop(5)...pop(1)产生的；
	我们得出第一个规律：当前的元素不等于栈顶则顺序有误。代码描述为：
	if(s.empty()) return FALSE;
	if(temp==s.top()) s.pop();
	else return FALSE;
	我们再看一组测试：
	输入 
	5
	32451
	Yes
	经过push(1,2,3)pop(3)pop(2)push(4)pop(4)push(5)pop(5)pop(1)在第四步时入栈4，此时入栈仅仅为4而不是1~4，
	说明需要对入栈规则修改:
	容易看出，入栈的元素需要在初始化时没有入栈，即比输入串首元素大。但是在不断入栈的过程中，后入栈的需要比之前入栈的所有数大，
	即大于当前栈内元素最大值，因此设置变量max记录当前最大值，当前元素大于最大值时入栈max+1到当前元素的数，
	由于入栈元素是顺序递增1的，很容易计算。
	#include<iostream>
	#include<stack>
	using namespace std;
	stack<int> s;
	int main(){
	int n=0;
	int temp=0;
	int max=0;
	int flag=0;
	while(cin>>n){
		max=0;
		flag=0;
		while(n--){
			cin>>temp;
			if(temp>max){//当前元素大于最大值时入栈max+1到当前元素的数
				for(int i=max+1;i<=temp;i++){
					s.push(i);
				}
				s.pop();
				max=temp;
			}
			else if(temp==max) flag=1;//当前元素等于最大值时出错
			else if(temp<max){
				if(s.empty()) flag=1;//栈空出错
				else if(temp==s.top()) s.pop();//当前元素等于栈顶时弹出
				else flag=1;//不等于栈顶出错
			}
		}
		if(flag==0){//输出
			cout<<"Yes"<<endl;
		}
		else cout<<"No"<<endl;
		while(!s.empty()){d
			s.pop();
		}
	}
		return 0;}
****
