题目描述：求一个非负整数 N 的阶乘的精确值（阶乘不超过 3000 位）
========
类型：高精度运算、数组、时间/空间优化
-----
	自然我们可以想到实现高精度阶乘需要首先实现高精度的乘法计算，利用数组作为数据结构来存放每一位数进行运算
	数据结构：整型数组 存储方式：阶乘结果按十进制位倒序存放，数组[0]元素为结果最大位
	而对于高精度乘法，有两种实现的方式：
	第一种是直接将乘数乘入被乘数的每一位，接着将产生的进位传递给下一位
	第二种方法是将求高精度乘法的问题转化为求高精度加法（乘法的本质是多次加法）
	
<br>

	在解题前我们先讨论下测试数据的生成，题目要求3000位
	使用公式：
	log10(n!) 
	=log10(1∗2∗3…∗n) 
	=log10(1)+log10(2)+…+log10(n)
	实现：
	#include <iostream>
	#include <cmath>
	using namespace std;
	#define N 1142
	int main(){
		double digit_sum=0;
		int i;
		for(i=1;i<=N;i++)
			digit_sum+=log10(i);
		digit_sum=digit_sum+1;
		cout<<N<<"!的位数为:"<<int(digit_sum)<<endl;
		return 0;
	}

	第一次尝试这道题的时候我使用的是第二种方法（比较简单）😂
	利用高精度加法实现 
	#include <iostream>
	#include <cstring>
	using namespace std;
	int factorial[3001];//存放结果
	int _factorial[3001];//拷贝当前的结果
	void copyary(int a[],int b[],int n){//将数组b复制到数组a中
		for(int i=0;i<n;i++){
			a[i]=b[i];
		}
	}
	void ary_add(int a[],int b[],int &lena,int lenb){//将数组b加到数组a中
		//adding eles in a and b
		int max=lena>lenb?lena:lenb;
		for(int i=0;i<max;i++){
			a[i]+=b[i];
			a[i+1]+=a[i]/10;
			a[i]%=10;
		}
		if(a[max]!=0) lena++;
	}
	void ary_mtpl(int a[],int b,int &loc){//数组a和整数b相乘，loc为最高位
		//by adding array a[0:loc] for b times
		copyary(_factorial,a,loc);
		for(int i=1;i<b;i++){
			ary_add(a,_factorial,loc,loc);
		}
	}
	int main(){
		int n=0,loc=0,temp_n=0;
		memset(factorial,0,sizeof(factorial));
		while(cin>>n){//多组输入n
			temp_n=n;
			loc=0;//最高位初始化为0
			while(temp_n!=0){//初始化结果数组为n的倒叙按位存放
				factorial[loc]=temp_n%10;
				loc++;//current actual length of factorial[]
				temp_n/=10;
			}	
			while(n--){//阶乘
				ary_mtpl(factorial,n,loc);
			}
			for(int i=loc-1;i>=0;i--) cout<<factorial[i];
			cout<<endl;		
			memset(factorial,0,sizeof(factorial));
			memset(_factorial,0,sizeof(_factorial));
		}
		return 0;
	}
此方法拆分了阶乘计算为`阶乘->乘法->加法`但是明显存在运行时间慢的问题(RUN TIME ERROR)
因此改变策略为做乘法

	做乘法时为了节约时间开销，我们将数组的每一位存放4位数据，这样总体循环的次数为原来的0.25倍
	//每个数组的单元里面存放四位数字，直接利用乘法 
	#include<iostream>
	#include<cstring>
	#include<iomanip>//设置输出的格式
	#define N 10000 //定义最大位数为10000，并且在计算中限制4位进位
	using namespace std;
	int f[N]; //每一个数保存阶乘中的四位数
	int main()
	{
		int n,i,j,p,c; //p表示已经用了数组的几个数  c是进位
		while(cin>>n)
		{
			memset(f,0,sizeof(f));
			f[0]=1;
			p=1;
			for(i=2;i<=n;i++){
					c=0;
					for(j=0;j<p;j++){
								f[j]=f[j]*i+c;
								c=f[j]/N;
								f[j]=f[j]%N;
						}
						if(c)
						{
								p++;
								f[p-1]+=c;
						}
				}
				cout<<f[p-1];
				for(i=p-2;i>=0;i--)
						cout<<setw(4)<<setfill('0')<<f[i]; //不足4位前面补0 
				cout<<endl;
		}
		return 0;
}

